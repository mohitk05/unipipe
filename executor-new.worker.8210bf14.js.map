{"version":3,"sources":["../src/executor/executor-new.worker.ts"],"names":[],"mappings":"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","file":"executor-new.worker.8210bf14.js","sourceRoot":"../public","sourcesContent":["import { NodeType, InPinType, OutPinType } from \"../context/main\";\nimport { ElementType } from \"../util/element\";\n\nconst ctx: Worker = self as any;\n\n/*\nAlgorithm\ncurrent: current node in the process\n- If current node is sink or it has no outputs, end the process.\n- If not, then\n    - Get data from all inputs for current node\n        - If the input node has data != null, then get that data, or else subscribe to their data\n    - Execute the processor for the current node with input values in scope.\n      The processor would always return a promise which upon completion will return the data.\n    - Set the resulting data to the node data (build something like computed data, where output pin can take only part of data too.)\n    - Go to next node connected to the output.\n        - For multiple nodes as output, proceed parallely.\n        - Start recursive executions for each branch.\n    - In each case, set current to the next node, call executeRecursive() with the new current\n*/\nlet globalElements: { [key: string]: ElementType } = {};\n\nclass ExecutorNode {\n    node: NodeType;\n    subscribers: Function[];\n    data: any | null;\n    isWaiting: boolean;\n\n    constructor(node: NodeType) {\n        this.node = node;\n        this.subscribers = [];\n        this.isWaiting = false;\n        this.data = null;\n    }\n\n    getNode(): NodeType {\n        return this.node;\n    }\n\n    getData(outPinName: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.data !== null) {\n                return resolve(this.data[outPinName]);\n            } else if (this.isWaiting) {\n                let timedOut = false;\n                const timeout = setTimeout(() => {\n                    timedOut = true;\n                    reject({\n                        code: 500,\n                        message: \"Input node execution timed out.\",\n                    });\n                }, 20000);\n                this.subscribers.push(() => {\n                    if (!timedOut) {\n                        clearTimeout(timeout);\n                        resolve(this.data[outPinName]);\n                    }\n                });\n            } else {\n                this.isWaiting = true;\n                reject({\n                    code: 400,\n                    message: `Input node needs to be executed.`,\n                });\n            }\n        });\n    }\n\n    execute(scopeData: any) {\n        const processor = globalElements[this.node.type].processor;\n        return new Promise(async (res, rej) => {\n            try {\n                ctx.postMessage({\n                    type: \"update_node\",\n                    node: this.node.id,\n                    update: {\n                        status: 1,\n                    },\n                });\n                const data = await eval(\n                    `(${processor})({ ...scopeData, ctx, node: this.node })`\n                );\n                this.data = data;\n                this.subscribers.forEach((s) => s());\n                ctx.postMessage({\n                    type: \"update_node\",\n                    node: this.node.id,\n                    update: {\n                        status: 2,\n                    },\n                });\n                res(data);\n            } catch (e: unknown) {\n                if (e instanceof Error) {\n                    rej(\n                        `Error executing node - ${\n                            globalElements[this.node.type].type\n                        } (${this.node.id}). Message: ${e.message}`\n                    );\n                    ctx.postMessage({\n                        type: \"update_node\",\n                        node: this.node.id,\n                        update: {\n                            status: 3,\n                        },\n                    });\n                }\n            } finally {\n                this.isWaiting = false;\n            }\n        });\n    }\n}\n\nconst execute = (\n    nodes: NodeType[],\n    inputPins: { [key: string]: InPinType },\n    outputPins: { [key: string]: OutPinType },\n    elements: { [key: string]: ElementType }\n) => {\n    globalElements = elements;\n    let nodeMap: { [key: string]: ExecutorNode } = {};\n    nodes.forEach((node) => {\n        ctx.postMessage({\n            type: \"update_node\",\n            node: node.id,\n            update: {\n                status: 0,\n            },\n        });\n        nodeMap[node.id] = new ExecutorNode(node);\n    });\n    const executeRecursive = async (current: string) => {\n        const currentNode = nodeMap[current];\n        const inputs = currentNode.getNode().inputs;\n        let inputPromises: Promise<any>[] = [];\n        inputs?.forEach((input) => {\n            const inputPin = inputPins[input];\n            if (inputPin.ref) {\n                const inputRefPin = outputPins[inputPin.ref];\n                const inputNode = nodeMap[inputRefPin.node];\n                inputPromises.push(\n                    new Promise((res, rej) => {\n                        inputNode\n                            .getData(inputRefPin.name)\n                            .then((data) => {\n                                res({ data, name: inputPin.name });\n                            })\n                            .catch(\n                                async ({\n                                    code,\n                                    message,\n                                }: {\n                                    code: number;\n                                    message: string;\n                                }) => {\n                                    if (code === 400) {\n                                        executeRecursive(inputNode.node.id);\n                                    } else {\n                                        rej(message);\n                                    }\n                                }\n                            );\n                    })\n                );\n            }\n        });\n\n        // separate input forEach from logic of moving to next node\n\n        await Promise.all(inputPromises)\n            .then((results) => {\n                let scopeData: { [key: string]: any } = {};\n                results.forEach((res) => {\n                    scopeData[res.name] = res.data;\n                });\n                currentNode\n                    .execute(scopeData)\n                    .then((data: any) => {\n                        const moveToNextNode = (out: string) => {\n                            const outPinRefs = outputPins[out].refs;\n                            let nextNodes: {\n                                [id: string]: 1 | undefined;\n                            } = {};\n                            outPinRefs?.forEach((oRef) => {\n                                const nextNode = inputPins[oRef].node;\n                                if (!nextNodes[nextNode]) {\n                                    executeRecursive(nextNode);\n                                    nextNodes[nextNode] = 1;\n                                }\n                            });\n                        };\n                        if (\n                            currentNode.getNode().outputs?.length &&\n                            ![\"sink\", \"conditional\"].includes(\n                                globalElements[currentNode.getNode().type].type\n                            ) &&\n                            currentNode.getNode().outputs?.length\n                        ) {\n                            currentNode\n                                .getNode()\n                                .outputs.forEach(moveToNextNode);\n                        } else if (\n                            globalElements[currentNode.getNode().type].type ==\n                            \"conditional\"\n                        ) {\n                            let next: string = \"\";\n                            if (data.true) {\n                                next = currentNode.getNode().outputs[0];\n                            } else {\n                                next = currentNode.getNode().outputs[1];\n                            }\n                            moveToNextNode(next);\n                        }\n                    })\n                    .catch((e) => {\n                        throw new Error(e);\n                    });\n            })\n            .catch((e) => {\n                console.log(e);\n            });\n    };\n\n    const headNode = findHeadNode(nodes, inputPins, outputPins);\n    executeRecursive(headNode);\n};\n\nconst findHeadNode = (\n    nodes: NodeType[],\n    inputPins: { [id: string]: InPinType },\n    outputPins: { [id: string]: OutPinType }\n): string => {\n    /* Algorithm: Find all nodes which do not have an input pin,\n\t\tfor all such pins, filter those whose outputs have only self as inputs\n\t*/\n    const nodeMap: { [id: string]: NodeType } = {};\n    nodes.forEach((node) => {\n        nodeMap[node.id] = node;\n    });\n    const nodesWithoutInputs = nodes.filter((node: NodeType) => {\n        return !node.inputs?.length;\n    });\n\n    const headNodes = nodesWithoutInputs.filter((node: NodeType) => {\n        let pass = true;\n        node.outputs.forEach((out) => {\n            if (pass) {\n                let outPin = outputPins[out];\n                outPin.refs?.forEach((ref) => {\n                    if (pass) {\n                        let refInputPin = inputPins[ref];\n                        let refNode: NodeType = nodeMap[refInputPin.node];\n                        let refNodeInputPins = refNode.inputs.map(\n                            (i) => inputPins[i]\n                        );\n\n                        refNodeInputPins.forEach((refNodeInputPin) => {\n                            if (\n                                pass &&\n                                refNodeInputPin.ref &&\n                                refNodeInputPin.ref !== out\n                            ) {\n                                pass = false;\n                            }\n                        });\n                    }\n                });\n            }\n        });\n\n        return pass;\n    });\n\n    // Simply return the first node without any inputs.\n    return nodesWithoutInputs[0] ? nodesWithoutInputs[0].id : nodes[0].id;\n};\n\nctx.addEventListener(\"message\", (e: MessageEvent) => {\n    const data: { action: string; data: any } = e.data;\n    const action = data.action;\n\n    switch (action) {\n        case \"execute\":\n            execute(\n                data.data.nodes,\n                data.data.inputPins,\n                data.data.outputPins,\n                data.data.elements\n            );\n            return;\n        default:\n            return;\n    }\n});\n"]}