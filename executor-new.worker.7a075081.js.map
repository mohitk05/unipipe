{"version":3,"sources":["../src/executor/executor-new.worker.ts"],"names":[],"mappings":"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","file":"executor-new.worker.7a075081.js","sourceRoot":"../public","sourcesContent":["import { NodeType, InPinType, OutPinType } from \"../context/main\";\nimport { ElementType } from \"../util/element\";\n\nconst ctx: Worker = self as any;\n\n/*\nAlgorithm\ncurrent: current node in the process\n- If current node is sink or it has no outputs, end the process.\n- If not, then\n    - Get data from all inputs for current node\n        - If the input node has data != null, then get that data, or else subscribe to their data\n    - Execute the processor for the current node with input values in scope.\n      The processor would always return a promise which upon completion will return the data.\n    - Set the resulting data to the node data (build something like computed data, where output pin can take only part of data too.)\n    - Go to next node connected to the output.\n        - For multiple nodes as output, proceed parallely.\n        - Start recursive executions for each branch.\n    - In each case, set current to the next node, call executeRecursive() with the new current\n*/\nlet globalElements: { [key: string]: ElementType } = {};\n\nclass ExecutorNode {\n    node: NodeType;\n    subscribers: Function[];\n    data: any | null;\n    isWaiting: boolean;\n\n    constructor(node: NodeType) {\n        this.node = node;\n        this.subscribers = [];\n        this.isWaiting = false;\n        this.data = null;\n    }\n\n    getNode(): NodeType {\n        return this.node;\n    }\n\n    getData(outPinName: string): Promise<any> {\n        return new Promise((resolve, reject) => {\n            if (this.data !== null) {\n                return resolve(this.data[outPinName]);\n            } else if (this.isWaiting) {\n                let timedOut = false;\n                const timeout = setTimeout(() => {\n                    timedOut = true;\n                    reject({\n                        code: 500,\n                        message: \"Input node execution timed out.\",\n                    });\n                }, 20000);\n                this.subscribers.push(() => {\n                    if (!timedOut) {\n                        clearTimeout(timeout);\n                        resolve(this.data[outPinName]);\n                    }\n                });\n            } else {\n                this.isWaiting = true;\n                reject({\n                    code: 400,\n                    message: `Input node needs to be executed.`,\n                });\n            }\n        });\n    }\n\n    execute(scopeData: any) {\n        const processor = globalElements[this.node.type].processor;\n        return new Promise(async (res, rej) => {\n            try {\n                ctx.postMessage({\n                    type: \"update_node\",\n                    node: this.node.id,\n                    update: {\n                        status: 1,\n                    },\n                });\n                const data = await eval(\n                    `(${processor})({ ...scopeData, ctx, node: this.node })`\n                );\n                this.data = data;\n                this.subscribers.forEach((s) => s());\n                ctx.postMessage({\n                    type: \"update_node\",\n                    node: this.node.id,\n                    update: {\n                        status: 2,\n                    },\n                });\n                res(data);\n            } catch (e: unknown) {\n                if (e instanceof Error) {\n                    rej(\n                        `Error executing node - ${\n                            globalElements[this.node.type].type\n                        } (${this.node.id}). Message: ${e.message}`\n                    );\n                    ctx.postMessage({\n                        type: \"update_node\",\n                        node: this.node.id,\n                        update: {\n                            status: 3,\n                        },\n                    });\n                }\n            } finally {\n                this.isWaiting = false;\n            }\n        });\n    }\n}\n\nconst execute = (\n    nodes: NodeType[],\n    inputPins: { [key: string]: InPinType },\n    outputPins: { [key: string]: OutPinType },\n    elements: { [key: string]: ElementType }\n) => {\n    globalElements = elements;\n    let nodeMap: { [key: string]: ExecutorNode } = {};\n    nodes.forEach((node) => {\n        ctx.postMessage({\n            type: \"update_node\",\n            node: node.id,\n            update: {\n                status: 0,\n            },\n        });\n        nodeMap[node.id] = new ExecutorNode(node);\n    });\n    const executeRecursive = async (current: string) => {\n        const currentNode = nodeMap[current];\n        const inputs = currentNode.getNode().inputs;\n        let inputPromises: Promise<any>[] = [];\n        inputs?.forEach((input) => {\n            const inputPin = inputPins[input];\n            if (inputPin.ref) {\n                const inputRefPin = outputPins[inputPin.ref];\n                const inputNode = nodeMap[inputRefPin.node];\n                inputPromises.push(\n                    new Promise((res, rej) => {\n                        inputNode\n                            .getData(inputRefPin.name)\n                            .then((data) => {\n                                res({ data, name: inputPin.name });\n                            })\n                            .catch(\n                                async ({\n                                    code,\n                                    message,\n                                }: {\n                                    code: number;\n                                    message: string;\n                                }) => {\n                                    if (code === 400) {\n                                        executeRecursive(inputNode.node.id);\n                                    } else {\n                                        rej(message);\n                                    }\n                                }\n                            );\n                    })\n                );\n            }\n        });\n\n        // separate input forEach from logic of moving to next node\n\n        await Promise.all(inputPromises)\n            .then((results) => {\n                let scopeData: { [key: string]: any } = {};\n                results.forEach((res) => {\n                    scopeData[res.name] = res.data;\n                });\n                currentNode\n                    .execute(scopeData)\n                    .then((data: any) => {\n                        const moveToNextNode = (out: string) => {\n                            const outPinRefs = outputPins[out].refs;\n                            let nextNodes: {\n                                [id: string]: 1 | undefined;\n                            } = {};\n                            outPinRefs?.forEach((oRef) => {\n                                const nextNode = inputPins[oRef].node;\n                                if (!nextNodes[nextNode]) {\n                                    executeRecursive(nextNode);\n                                    nextNodes[nextNode] = 1;\n                                }\n                            });\n                        };\n                        if (\n                            currentNode.getNode().outputs?.length &&\n                            ![\"sink\", \"conditional\"].includes(\n                                globalElements[currentNode.getNode().type].type\n                            ) &&\n                            currentNode.getNode().outputs?.length\n                        ) {\n                            currentNode\n                                .getNode()\n                                .outputs.forEach(moveToNextNode);\n                        } else if (\n                            globalElements[currentNode.getNode().type].type ==\n                            \"conditional\"\n                        ) {\n                            let next: string = \"\";\n                            if (data.true) {\n                                next = currentNode.getNode().outputs[0];\n                            } else {\n                                next = currentNode.getNode().outputs[1];\n                            }\n                            moveToNextNode(next);\n                        }\n                    })\n                    .catch((e) => {\n                        throw new Error(e);\n                    });\n            })\n            .catch((e) => {\n                console.log(e);\n            });\n    };\n\n    const headNode = findHeadNode(nodes, inputPins, outputPins);\n    executeRecursive(headNode);\n};\n\nconst findHeadNode = (\n    nodes: NodeType[],\n    inputPins: { [id: string]: InPinType },\n    outputPins: { [id: string]: OutPinType }\n): string => {\n    /* Algorithm: Find all nodes which do not have an input pin,\n\t\tfor all such pins, filter those whose outputs have only self as inputs\n\t*/\n    const nodeMap: { [id: string]: NodeType } = {};\n    nodes.forEach((node) => {\n        nodeMap[node.id] = node;\n    });\n    const nodesWithoutInputs = nodes.filter((node: NodeType) => {\n        return !node.inputs?.length;\n    });\n\n    const headNodes = nodesWithoutInputs.filter((node: NodeType) => {\n        let pass = true;\n        node.outputs.forEach((out) => {\n            if (pass) {\n                let outPin = outputPins[out];\n                outPin.refs?.forEach((ref) => {\n                    if (pass) {\n                        let refInputPin = inputPins[ref];\n                        let refNode: NodeType = nodeMap[refInputPin.node];\n                        let refNodeInputPins = refNode.inputs.map(\n                            (i) => inputPins[i]\n                        );\n\n                        refNodeInputPins.forEach((refNodeInputPin) => {\n                            if (\n                                pass &&\n                                refNodeInputPin.ref &&\n                                refNodeInputPin.ref !== out\n                            ) {\n                                pass = false;\n                            }\n                        });\n                    }\n                });\n            }\n        });\n\n        return pass;\n    });\n\n    // Simply return the first node without any inputs.\n    return nodesWithoutInputs[0] ? nodesWithoutInputs[0].id : nodes[0].id;\n};\n\nctx.addEventListener(\"message\", (e: MessageEvent) => {\n    const data: { action: string; data: any } = e.data;\n    const action = data.action;\n\n    switch (action) {\n        case \"execute\":\n            execute(\n                data.data.nodes,\n                data.data.inputPins,\n                data.data.outputPins,\n                data.data.elements\n            );\n            return;\n        default:\n            return;\n    }\n});\n"]}